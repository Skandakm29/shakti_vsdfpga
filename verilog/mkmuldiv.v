//
// Generated by Bluespec Compiler, version 2021.07 (build 4cac6eba)
//
// On Fri Mar  7 14:49:28 IST 2025
//
//
// Ports:
// Name                         I/O  size props
// get_inputs                     O   138
// RDY_get_inputs                 O     1 const
// delayed_output                 O   138
// RDY_delayed_output             O     1
// CLK                            I     1 clock
// RST_N                          I     1 reset
// get_inputs_operand1            I    64
// get_inputs_operand2            I    64
// get_inputs_funct3              I     3
// get_inputs_word32              I     1
// EN_get_inputs                  I     1
// EN_delayed_output              I     1 unused
//
// Combinational paths from inputs to outputs:
//   (get_inputs_operand1,
//    get_inputs_operand2,
//    get_inputs_funct3,
//    get_inputs_word32) -> get_inputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkmuldiv(CLK,
		RST_N,

		get_inputs_operand1,
		get_inputs_operand2,
		get_inputs_funct3,
		get_inputs_word32,
		EN_get_inputs,
		get_inputs,
		RDY_get_inputs,

		EN_delayed_output,
		delayed_output,
		RDY_delayed_output);
  input  CLK;
  input  RST_N;

  // actionvalue method get_inputs
  input  [63 : 0] get_inputs_operand1;
  input  [63 : 0] get_inputs_operand2;
  input  [2 : 0] get_inputs_funct3;
  input  get_inputs_word32;
  input  EN_get_inputs;
  output [137 : 0] get_inputs;
  output RDY_get_inputs;

  // actionvalue method delayed_output
  input  EN_delayed_output;
  output [137 : 0] delayed_output;
  output RDY_delayed_output;

  // signals for module outputs
  wire [137 : 0] delayed_output, get_inputs;
  wire RDY_delayed_output, RDY_get_inputs;

  // register mul_div
  reg mul_div;
  wire mul_div_D_IN, mul_div_EN;

  // register mult_reg_a
  reg [127 : 0] mult_reg_a;
  wire [127 : 0] mult_reg_a_D_IN;
  wire mult_reg_a_EN;

  // register mult_reg_b
  reg [127 : 0] mult_reg_b;
  wire [127 : 0] mult_reg_b_D_IN;
  wire mult_reg_b_EN;

  // register rg_complement
  reg rg_complement;
  reg rg_complement_D_IN;
  wire rg_complement_EN;

  // register rg_count
  reg [6 : 0] rg_count;
  wire [6 : 0] rg_count_D_IN;
  wire rg_count_EN;

  // register rg_sign_op1
  reg rg_sign_op1;
  wire rg_sign_op1_D_IN, rg_sign_op1_EN;

  // register rg_upperbits
  reg rg_upperbits;
  wire rg_upperbits_D_IN, rg_upperbits_EN;

  // register rg_word32
  reg rg_word32;
  wire rg_word32_D_IN, rg_word32_EN;

  // ports of submodule divider
  wire [63 : 0] divider_get_inputs_op1,
		divider_get_inputs_op2,
		divider_quo_rem;
  wire divider_EN_get_inputs, divider_get_inputs_qr;

  // rule scheduling signals
  wire CAN_FIRE_RL_increment_counter,
       CAN_FIRE_delayed_output,
       CAN_FIRE_get_inputs,
       WILL_FIRE_RL_increment_counter,
       WILL_FIRE_delayed_output,
       WILL_FIRE_get_inputs;

  // inputs to muxes for submodule ports
  wire [6 : 0] MUX_rg_count_write_1__VAL_2;
  wire MUX_rg_count_write_1__SEL_1;

  // declarations used by system tasks
  // synopsys translate_off
  reg TASK_testplusargs___d102;
  reg TASK_testplusargs___d103;
  reg TASK_testplusargs___d104;
  reg [63 : 0] v__h2312;
  reg TASK_testplusargs___d72;
  reg TASK_testplusargs___d73;
  reg TASK_testplusargs___d74;
  reg [63 : 0] v__h1068;
  reg TASK_testplusargs___d13;
  reg TASK_testplusargs___d14;
  reg TASK_testplusargs___d15;
  reg [63 : 0] v__h482;
  reg TASK_testplusargs___d25;
  reg TASK_testplusargs___d26;
  reg TASK_testplusargs___d27;
  reg [63 : 0] v__h619;
  reg rg_count_EQ_8_AND_NOT_mul_div_OR_rg_count_EQ_6_ETC___d18;
  reg NOT_rg_count_EQ_8_0_OR_mul_div_1_AND_NOT_rg_co_ETC___d30;
  reg NOT_get_inputs_funct3_BIT_2_2_8_AND_TASK_testp_ETC___d77;
  // synopsys translate_on

  // remaining internal signals
  wire [255 : 0] mult_reg_a_26_MUL_mult_reg_b_27___d128;
  wire [127 : 0] _theResult____h2243, reslt___1__h2440, reslt__h2242;
  wire [63 : 0] IF_get_inputs_word32_THEN_IF_get_inputs_funct3_ETC___d38,
		IF_get_inputs_word32_THEN_IF_get_inputs_funct3_ETC___d44,
		_theResult_____3_fst__h1828,
		_theResult___fst__h879,
		_theResult___snd__h880,
		default_out___1__h2157,
		default_out__h1768,
		op1__h823,
		op2__h824,
		product__h2244,
		t1__h821,
		t2__h822,
		x__h2153,
		y_avValue_fst__h1760;
  wire [31 : 0] default_out768_BITS_31_TO_0__q3,
		get_inputs_operand1_BITS_31_TO_0__q1,
		get_inputs_operand2_BITS_31_TO_0__q2,
		theResult__243_BITS_31_TO_0__q4;
  wire [6 : 0] x__h702;
  wire IF_get_inputs_word32_THEN_IF_get_inputs_funct3_ETC___d88,
       mul_div_AND_rg_upperbits_09_10_AND_rg_compleme_ETC___d118,
       x__h1125,
       x__h1328;

  // actionvalue method get_inputs
  assign get_inputs =
	     { get_inputs_funct3[2] &&
	       IF_get_inputs_word32_THEN_IF_get_inputs_funct3_ETC___d44 ==
	       64'd0,
	       2'd2,
	       x__h2153,
	       64'hAAAAAAAAAAAAAAAA /* unspecified value */ ,
	       6'b101010 /* unspecified value */ ,
	       1'd0 } ;
  assign RDY_get_inputs = 1'd1 ;
  assign CAN_FIRE_get_inputs = 1'd1 ;
  assign WILL_FIRE_get_inputs = EN_get_inputs ;

  // actionvalue method delayed_output
  assign delayed_output =
	     { 3'd6,
	       product__h2244,
	       64'hAAAAAAAAAAAAAAAA /* unspecified value */ ,
	       6'b101010 /* unspecified value */ ,
	       1'd0 } ;
  assign RDY_delayed_output =
	     rg_count == 7'd8 && !mul_div || rg_count == 7'd65 && mul_div ;
  assign CAN_FIRE_delayed_output =
	     rg_count == 7'd8 && !mul_div || rg_count == 7'd65 && mul_div ;
  assign WILL_FIRE_delayed_output = EN_delayed_output ;

  // submodule divider
  mkrestoring_div divider(.CLK(CLK),
			  .RST_N(RST_N),
			  .get_inputs_op1(divider_get_inputs_op1),
			  .get_inputs_op2(divider_get_inputs_op2),
			  .get_inputs_qr(divider_get_inputs_qr),
			  .EN_get_inputs(divider_EN_get_inputs),
			  .RDY_get_inputs(),
			  .quo_rem(divider_quo_rem),
			  .RDY_quo_rem());

  // rule RL_increment_counter
  assign CAN_FIRE_RL_increment_counter = rg_count != 7'd0 ;
  assign WILL_FIRE_RL_increment_counter =
	     CAN_FIRE_RL_increment_counter && !EN_get_inputs ;

  // inputs to muxes for submodule ports
  assign MUX_rg_count_write_1__SEL_1 =
	     EN_get_inputs &&
	     (!get_inputs_funct3[2] ||
	      IF_get_inputs_word32_THEN_IF_get_inputs_funct3_ETC___d44 !=
	      64'd0) ;
  assign MUX_rg_count_write_1__VAL_2 =
	     (rg_count == 7'd8 && !mul_div || rg_count == 7'd65 && mul_div) ?
	       7'd0 :
	       x__h702 ;

  // register mul_div
  assign mul_div_D_IN = get_inputs_funct3[2] ;
  assign mul_div_EN = EN_get_inputs ;

  // register mult_reg_a
  assign mult_reg_a_D_IN = { 64'd0, op1__h823 } ;
  assign mult_reg_a_EN = EN_get_inputs && !get_inputs_funct3[2] ;

  // register mult_reg_b
  assign mult_reg_b_D_IN = { 64'd0, op2__h824 } ;
  assign mult_reg_b_EN = EN_get_inputs && !get_inputs_funct3[2] ;

  // register rg_complement
  always@(get_inputs_funct3 or
	  IF_get_inputs_word32_THEN_IF_get_inputs_funct3_ETC___d88 or
	  IF_get_inputs_word32_THEN_IF_get_inputs_funct3_ETC___d38)
  begin
    case (get_inputs_funct3)
      3'd1, 3'd4:
	  rg_complement_D_IN =
	      IF_get_inputs_word32_THEN_IF_get_inputs_funct3_ETC___d88;
      3'd2:
	  rg_complement_D_IN =
	      IF_get_inputs_word32_THEN_IF_get_inputs_funct3_ETC___d38[63];
      default: rg_complement_D_IN = get_inputs_funct3 == 3'd6;
    endcase
  end
  assign rg_complement_EN = MUX_rg_count_write_1__SEL_1 ;

  // register rg_count
  assign rg_count_D_IN =
	     MUX_rg_count_write_1__SEL_1 ?
	       7'd1 :
	       MUX_rg_count_write_1__VAL_2 ;
  assign rg_count_EN =
	     EN_get_inputs &&
	     (!get_inputs_funct3[2] ||
	      IF_get_inputs_word32_THEN_IF_get_inputs_funct3_ETC___d44 !=
	      64'd0) ||
	     WILL_FIRE_RL_increment_counter ;

  // register rg_sign_op1
  assign rg_sign_op1_D_IN =
	     IF_get_inputs_word32_THEN_IF_get_inputs_funct3_ETC___d38[63] ;
  assign rg_sign_op1_EN = EN_get_inputs ;

  // register rg_upperbits
  assign rg_upperbits_D_IN =
	     get_inputs_funct3[2] ?
	       get_inputs_funct3[1] :
	       get_inputs_funct3[1:0] != 2'd0 ;
  assign rg_upperbits_EN = MUX_rg_count_write_1__SEL_1 ;

  // register rg_word32
  assign rg_word32_D_IN = get_inputs_word32 ;
  assign rg_word32_EN = MUX_rg_count_write_1__SEL_1 ;

  // submodule divider
  assign divider_get_inputs_op1 = op1__h823 ;
  assign divider_get_inputs_op2 = op2__h824 ;
  assign divider_get_inputs_qr = get_inputs_funct3[1] ;
  assign divider_EN_get_inputs =
	     EN_get_inputs && get_inputs_funct3[2] &&
	     IF_get_inputs_word32_THEN_IF_get_inputs_funct3_ETC___d44 !=
	     64'd0 ;

  // remaining internal signals
  assign IF_get_inputs_word32_THEN_IF_get_inputs_funct3_ETC___d38 =
	     get_inputs_word32 ?
	       _theResult___fst__h879 :
	       get_inputs_operand1 ;
  assign IF_get_inputs_word32_THEN_IF_get_inputs_funct3_ETC___d44 =
	     get_inputs_word32 ?
	       _theResult___snd__h880 :
	       get_inputs_operand2 ;
  assign IF_get_inputs_word32_THEN_IF_get_inputs_funct3_ETC___d88 =
	     IF_get_inputs_word32_THEN_IF_get_inputs_funct3_ETC___d38[63] ^
	     IF_get_inputs_word32_THEN_IF_get_inputs_funct3_ETC___d44[63] ;
  assign _theResult_____3_fst__h1828 =
	     get_inputs_funct3[1] ?
	       IF_get_inputs_word32_THEN_IF_get_inputs_funct3_ETC___d38 :
	       64'hFFFFFFFFFFFFFFFF ;
  assign _theResult____h2243 =
	     (mul_div_AND_rg_upperbits_09_10_AND_rg_compleme_ETC___d118 ||
	      mul_div && rg_complement && !rg_upperbits ||
	      !mul_div && rg_complement) ?
	       reslt___1__h2440 :
	       reslt__h2242 ;
  assign _theResult___fst__h879 =
	     get_inputs_funct3[0] ?
	       { 32'd0, get_inputs_operand1[31:0] } :
	       { {32{get_inputs_operand1_BITS_31_TO_0__q1[31]}},
		 get_inputs_operand1_BITS_31_TO_0__q1 } ;
  assign _theResult___snd__h880 =
	     get_inputs_funct3[0] ?
	       { 32'd0, get_inputs_operand2[31:0] } :
	       { {32{get_inputs_operand2_BITS_31_TO_0__q2[31]}},
		 get_inputs_operand2_BITS_31_TO_0__q2 } ;
  assign default_out768_BITS_31_TO_0__q3 = default_out__h1768[31:0] ;
  assign default_out___1__h2157 =
	     { {32{default_out768_BITS_31_TO_0__q3[31]}},
	       default_out768_BITS_31_TO_0__q3 } ;
  assign default_out__h1768 =
	     get_inputs_funct3[2] ?
	       y_avValue_fst__h1760 :
	       64'hFFFFFFFFFFFFFFFF ;
  assign get_inputs_operand1_BITS_31_TO_0__q1 = get_inputs_operand1[31:0] ;
  assign get_inputs_operand2_BITS_31_TO_0__q2 = get_inputs_operand2[31:0] ;
  assign mul_div_AND_rg_upperbits_09_10_AND_rg_compleme_ETC___d118 =
	     mul_div && rg_upperbits && rg_complement &&
	     divider_quo_rem[63] != rg_sign_op1 ;
  assign mult_reg_a_26_MUL_mult_reg_b_27___d128 = mult_reg_a * mult_reg_b ;
  assign op1__h823 =
	     (t1__h821 ^
	      IF_get_inputs_word32_THEN_IF_get_inputs_funct3_ETC___d38) +
	     { 63'd0, x__h1125 } ;
  assign op2__h824 =
	     (t2__h822 ^
	      IF_get_inputs_word32_THEN_IF_get_inputs_funct3_ETC___d44) +
	     { 63'd0, x__h1328 } ;
  assign product__h2244 =
	     rg_word32 ?
	       { {32{theResult__243_BITS_31_TO_0__q4[31]}},
		 theResult__243_BITS_31_TO_0__q4 } :
	       ((!mul_div && rg_upperbits) ?
		  _theResult____h2243[127:64] :
		  _theResult____h2243[63:0]) ;
  assign reslt___1__h2440 = ~reslt__h2242 + 128'd1 ;
  assign reslt__h2242 =
	     mul_div ?
	       { 64'd0, divider_quo_rem } :
	       mult_reg_a_26_MUL_mult_reg_b_27___d128[127:0] ;
  assign t1__h821 = {64{x__h1125}} ;
  assign t2__h822 = {64{x__h1328}} ;
  assign theResult__243_BITS_31_TO_0__q4 = _theResult____h2243[31:0] ;
  assign x__h1125 =
	     !get_inputs_funct3[2] &&
	     get_inputs_funct3[0] ^ get_inputs_funct3[1] &&
	     IF_get_inputs_word32_THEN_IF_get_inputs_funct3_ETC___d38[63] ||
	     get_inputs_funct3[2] && !get_inputs_funct3[0] &&
	     IF_get_inputs_word32_THEN_IF_get_inputs_funct3_ETC___d38[63] ;
  assign x__h1328 =
	     !get_inputs_funct3[2] && get_inputs_funct3[1:0] == 2'd1 &&
	     IF_get_inputs_word32_THEN_IF_get_inputs_funct3_ETC___d44[63] ||
	     get_inputs_funct3[2] && !get_inputs_funct3[0] &&
	     IF_get_inputs_word32_THEN_IF_get_inputs_funct3_ETC___d44[63] ;
  assign x__h2153 =
	     get_inputs_word32 ? default_out___1__h2157 : default_out__h1768 ;
  assign x__h702 = rg_count + 7'd1 ;
  assign y_avValue_fst__h1760 =
	     (IF_get_inputs_word32_THEN_IF_get_inputs_funct3_ETC___d44 ==
	      64'd0) ?
	       _theResult_____3_fst__h1828 :
	       64'hFFFFFFFFFFFFFFFF ;

  // handling of inlined registers

  always@(posedge CLK or `BSV_RESET_EDGE RST_N)
  if (RST_N == `BSV_RESET_VALUE)
    begin
      mul_div <= `BSV_ASSIGNMENT_DELAY 1'd0;
      mult_reg_a <= `BSV_ASSIGNMENT_DELAY 128'd0;
      mult_reg_b <= `BSV_ASSIGNMENT_DELAY 128'd0;
      rg_complement <= `BSV_ASSIGNMENT_DELAY 1'd0;
      rg_count <= `BSV_ASSIGNMENT_DELAY 7'd0;
      rg_sign_op1 <= `BSV_ASSIGNMENT_DELAY 1'd0;
      rg_upperbits <= `BSV_ASSIGNMENT_DELAY 1'd0;
      rg_word32 <= `BSV_ASSIGNMENT_DELAY 1'd0;
    end
  else
    begin
      if (mul_div_EN) mul_div <= `BSV_ASSIGNMENT_DELAY mul_div_D_IN;
      if (mult_reg_a_EN) mult_reg_a <= `BSV_ASSIGNMENT_DELAY mult_reg_a_D_IN;
      if (mult_reg_b_EN) mult_reg_b <= `BSV_ASSIGNMENT_DELAY mult_reg_b_D_IN;
      if (rg_complement_EN)
	rg_complement <= `BSV_ASSIGNMENT_DELAY rg_complement_D_IN;
      if (rg_count_EN) rg_count <= `BSV_ASSIGNMENT_DELAY rg_count_D_IN;
      if (rg_sign_op1_EN)
	rg_sign_op1 <= `BSV_ASSIGNMENT_DELAY rg_sign_op1_D_IN;
      if (rg_upperbits_EN)
	rg_upperbits <= `BSV_ASSIGNMENT_DELAY rg_upperbits_D_IN;
      if (rg_word32_EN) rg_word32 <= `BSV_ASSIGNMENT_DELAY rg_word32_D_IN;
    end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    mul_div = 1'h0;
    mult_reg_a = 128'hAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    mult_reg_b = 128'hAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    rg_complement = 1'h0;
    rg_count = 7'h2A;
    rg_sign_op1 = 1'h0;
    rg_upperbits = 1'h0;
    rg_word32 = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_delayed_output)
	begin
	  TASK_testplusargs___d102 = $test$plusargs("fullverbose");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_delayed_output)
	begin
	  TASK_testplusargs___d103 = $test$plusargs("mmuldiv");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_delayed_output)
	begin
	  TASK_testplusargs___d104 = $test$plusargs("l0");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_delayed_output)
	begin
	  v__h2312 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_delayed_output &&
	  (TASK_testplusargs___d102 ||
	   TASK_testplusargs___d103 && TASK_testplusargs___d104))
	$write("[%10d", v__h2312, "] ");
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_delayed_output &&
	  (TASK_testplusargs___d102 ||
	   TASK_testplusargs___d103 && TASK_testplusargs___d104))
	$write("MULDIV: Responding with DelayedOut: %h", product__h2244);
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_delayed_output &&
	  (TASK_testplusargs___d102 ||
	   TASK_testplusargs___d103 && TASK_testplusargs___d104))
	$write("\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_get_inputs && !get_inputs_funct3[2])
	begin
	  TASK_testplusargs___d72 = $test$plusargs("fullverbose");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_get_inputs && !get_inputs_funct3[2])
	begin
	  TASK_testplusargs___d73 = $test$plusargs("mmuldiv");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_get_inputs && !get_inputs_funct3[2])
	begin
	  TASK_testplusargs___d74 = $test$plusargs("l0");
	  #0;
	end
    NOT_get_inputs_funct3_BIT_2_2_8_AND_TASK_testp_ETC___d77 =
	!get_inputs_funct3[2] &&
	(TASK_testplusargs___d72 ||
	 TASK_testplusargs___d73 && TASK_testplusargs___d74);
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_get_inputs && !get_inputs_funct3[2])
	begin
	  v__h1068 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_get_inputs &&
	  NOT_get_inputs_funct3_BIT_2_2_8_AND_TASK_testp_ETC___d77)
	$write("[%10d", v__h1068, "] ");
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_get_inputs &&
	  NOT_get_inputs_funct3_BIT_2_2_8_AND_TASK_testp_ETC___d77)
	$write("MULDIV : Inps to Mul. A:%h B:%h f3: %b",
	       op1__h823,
	       op2__h824,
	       get_inputs_funct3);
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_get_inputs &&
	  NOT_get_inputs_funct3_BIT_2_2_8_AND_TASK_testp_ETC___d77)
	$write("\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_increment_counter &&
	  (rg_count == 7'd8 && !mul_div || rg_count == 7'd65 && mul_div))
	begin
	  TASK_testplusargs___d13 = $test$plusargs("fullverbose");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_increment_counter &&
	  (rg_count == 7'd8 && !mul_div || rg_count == 7'd65 && mul_div))
	begin
	  TASK_testplusargs___d14 = $test$plusargs("mmuldiv");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_increment_counter &&
	  (rg_count == 7'd8 && !mul_div || rg_count == 7'd65 && mul_div))
	begin
	  TASK_testplusargs___d15 = $test$plusargs("l0");
	  #0;
	end
    rg_count_EQ_8_AND_NOT_mul_div_OR_rg_count_EQ_6_ETC___d18 =
	(rg_count == 7'd8 && !mul_div || rg_count == 7'd65 && mul_div) &&
	(TASK_testplusargs___d13 ||
	 TASK_testplusargs___d14 && TASK_testplusargs___d15);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_increment_counter &&
	  (rg_count == 7'd8 && !mul_div || rg_count == 7'd65 && mul_div))
	begin
	  v__h482 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_increment_counter &&
	  rg_count_EQ_8_AND_NOT_mul_div_OR_rg_count_EQ_6_ETC___d18)
	$write("[%10d", v__h482, "] ");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_increment_counter &&
	  rg_count_EQ_8_AND_NOT_mul_div_OR_rg_count_EQ_6_ETC___d18)
	$write("MULDIV : got output from Mul/Div. mul_div: %b", mul_div);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_increment_counter &&
	  rg_count_EQ_8_AND_NOT_mul_div_OR_rg_count_EQ_6_ETC___d18)
	$write("\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_increment_counter && (rg_count != 7'd8 || mul_div) &&
	  (rg_count != 7'd65 || !mul_div))
	begin
	  TASK_testplusargs___d25 = $test$plusargs("fullverbose");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_increment_counter && (rg_count != 7'd8 || mul_div) &&
	  (rg_count != 7'd65 || !mul_div))
	begin
	  TASK_testplusargs___d26 = $test$plusargs("mmuldiv");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_increment_counter && (rg_count != 7'd8 || mul_div) &&
	  (rg_count != 7'd65 || !mul_div))
	begin
	  TASK_testplusargs___d27 = $test$plusargs("l0");
	  #0;
	end
    NOT_rg_count_EQ_8_0_OR_mul_div_1_AND_NOT_rg_co_ETC___d30 =
	(rg_count != 7'd8 || mul_div) && (rg_count != 7'd65 || !mul_div) &&
	(TASK_testplusargs___d25 ||
	 TASK_testplusargs___d26 && TASK_testplusargs___d27);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_increment_counter && (rg_count != 7'd8 || mul_div) &&
	  (rg_count != 7'd65 || !mul_div))
	begin
	  v__h619 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_increment_counter &&
	  NOT_rg_count_EQ_8_0_OR_mul_div_1_AND_NOT_rg_co_ETC___d30)
	$write("[%10d", v__h619, "] ");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_increment_counter &&
	  NOT_rg_count_EQ_8_0_OR_mul_div_1_AND_NOT_rg_co_ETC___d30)
	$write("MULDIV : Waiting for mul/div to respond. Count: %d",
	       rg_count);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_increment_counter &&
	  NOT_rg_count_EQ_8_0_OR_mul_div_1_AND_NOT_rg_co_ETC___d30)
	$write("\n");
  end
  // synopsys translate_on
endmodule  // mkmuldiv

