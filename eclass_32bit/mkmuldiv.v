//
// Generated by Bluespec Compiler, version 2024.01 (build ae2a2fc6)
//
// On Mon Mar 31 00:26:12 IST 2025
//
//
// Ports:
// Name                         I/O  size props
// get_inputs                     O    74
// RDY_get_inputs                 O     1 const
// delayed_output                 O    74
// RDY_delayed_output             O     1
// CLK                            I     1 clock
// RST_N                          I     1 reset
// get_inputs_operand1            I    32
// get_inputs_operand2            I    32
// get_inputs_funct3              I     3
// EN_get_inputs                  I     1
// EN_delayed_output              I     1 unused
//
// Combinational paths from inputs to outputs:
//   (get_inputs_operand1, get_inputs_operand2, get_inputs_funct3) -> get_inputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkmuldiv(CLK,
		RST_N,

		get_inputs_operand1,
		get_inputs_operand2,
		get_inputs_funct3,
		EN_get_inputs,
		get_inputs,
		RDY_get_inputs,

		EN_delayed_output,
		delayed_output,
		RDY_delayed_output);
  input  CLK;
  input  RST_N;

  // actionvalue method get_inputs
  input  [31 : 0] get_inputs_operand1;
  input  [31 : 0] get_inputs_operand2;
  input  [2 : 0] get_inputs_funct3;
  input  EN_get_inputs;
  output [73 : 0] get_inputs;
  output RDY_get_inputs;

  // actionvalue method delayed_output
  input  EN_delayed_output;
  output [73 : 0] delayed_output;
  output RDY_delayed_output;

  // signals for module outputs
  wire [73 : 0] delayed_output, get_inputs;
  wire RDY_delayed_output, RDY_get_inputs;

  // register mul_div
  reg mul_div;
  wire mul_div_D_IN, mul_div_EN;

  // register mult_reg_a
  reg [63 : 0] mult_reg_a;
  wire [63 : 0] mult_reg_a_D_IN;
  wire mult_reg_a_EN;

  // register mult_reg_b
  reg [63 : 0] mult_reg_b;
  wire [63 : 0] mult_reg_b_D_IN;
  wire mult_reg_b_EN;

  // register rg_complement
  reg rg_complement;
  reg rg_complement_D_IN;
  wire rg_complement_EN;

  // register rg_count
  reg [5 : 0] rg_count;
  wire [5 : 0] rg_count_D_IN;
  wire rg_count_EN;

  // register rg_sign_op1
  reg rg_sign_op1;
  wire rg_sign_op1_D_IN, rg_sign_op1_EN;

  // register rg_upperbits
  reg rg_upperbits;
  wire rg_upperbits_D_IN, rg_upperbits_EN;

  // ports of submodule divider
  wire [31 : 0] divider_get_inputs_op1,
		divider_get_inputs_op2,
		divider_quo_rem;
  wire divider_EN_get_inputs, divider_get_inputs_qr;

  // rule scheduling signals
  wire CAN_FIRE_RL_increment_counter,
       CAN_FIRE_delayed_output,
       CAN_FIRE_get_inputs,
       WILL_FIRE_RL_increment_counter,
       WILL_FIRE_delayed_output,
       WILL_FIRE_get_inputs;

  // inputs to muxes for submodule ports
  wire [5 : 0] MUX_rg_count_write_1__VAL_2;
  wire MUX_rg_count_write_1__SEL_1;

  // declarations used by system tasks
  // synopsys translate_off
  reg TASK_testplusargs___d89;
  reg TASK_testplusargs___d90;
  reg TASK_testplusargs___d91;
  reg [63 : 0] v__h2070;
  reg TASK_testplusargs___d62;
  reg TASK_testplusargs___d63;
  reg TASK_testplusargs___d64;
  reg [63 : 0] v__h955;
  reg TASK_testplusargs___d13;
  reg TASK_testplusargs___d14;
  reg TASK_testplusargs___d15;
  reg [63 : 0] v__h451;
  reg TASK_testplusargs___d25;
  reg TASK_testplusargs___d26;
  reg TASK_testplusargs___d27;
  reg [63 : 0] v__h588;
  reg rg_count_EQ_4_AND_NOT_mul_div_OR_rg_count_EQ_3_ETC___d18;
  reg NOT_rg_count_EQ_4_0_OR_mul_div_1_AND_NOT_rg_co_ETC___d30;
  reg NOT_get_inputs_funct3_BIT_2_2_7_AND_TASK_testp_ETC___d67;
  // synopsys translate_on

  // remaining internal signals
  wire [127 : 0] mult_reg_a_13_MUL_mult_reg_b_14___d115;
  wire [63 : 0] _theResult____h2001, reslt___1__h2178, reslt__h2000;
  wire [31 : 0] _theResult_____2_fst__h1641,
		op1__h787,
		op2__h788,
		product__h2002,
		t1__h785,
		t2__h786,
		x__h1935,
		y_avValue_fst__h1574;
  wire [5 : 0] x__h671;
  wire get_inputs_operand1_BIT_31_3_XOR_get_inputs_op_ETC___d78,
       mul_div_AND_rg_upperbits_5_7_AND_rg_complement_ETC___d105,
       x__h1209,
       x__h1384;

  // actionvalue method get_inputs
  assign get_inputs =
	     { get_inputs_funct3[2] && get_inputs_operand2 == 32'd0,
	       2'd2,
	       x__h1935,
	       32'hAAAAAAAA /* unspecified value */ ,
	       6'b101010 /* unspecified value */ ,
	       1'd0 } ;
  assign RDY_get_inputs = 1'd1 ;
  assign CAN_FIRE_get_inputs = 1'd1 ;
  assign WILL_FIRE_get_inputs = EN_get_inputs ;

  // actionvalue method delayed_output
  assign delayed_output =
	     { 3'd6,
	       product__h2002,
	       32'hAAAAAAAA /* unspecified value */ ,
	       6'b101010 /* unspecified value */ ,
	       1'd0 } ;
  assign RDY_delayed_output =
	     rg_count == 6'd4 && !mul_div || rg_count == 6'd33 && mul_div ;
  assign CAN_FIRE_delayed_output =
	     rg_count == 6'd4 && !mul_div || rg_count == 6'd33 && mul_div ;
  assign WILL_FIRE_delayed_output = EN_delayed_output ;

  // submodule divider
  mkrestoring_div divider(.CLK(CLK),
			  .RST_N(RST_N),
			  .get_inputs_op1(divider_get_inputs_op1),
			  .get_inputs_op2(divider_get_inputs_op2),
			  .get_inputs_qr(divider_get_inputs_qr),
			  .EN_get_inputs(divider_EN_get_inputs),
			  .RDY_get_inputs(),
			  .quo_rem(divider_quo_rem),
			  .RDY_quo_rem());

  // rule RL_increment_counter
  assign CAN_FIRE_RL_increment_counter = rg_count != 6'd0 ;
  assign WILL_FIRE_RL_increment_counter =
	     CAN_FIRE_RL_increment_counter && !EN_get_inputs ;

  // inputs to muxes for submodule ports
  assign MUX_rg_count_write_1__SEL_1 =
	     EN_get_inputs &&
	     (!get_inputs_funct3[2] || get_inputs_operand2 != 32'd0) ;
  assign MUX_rg_count_write_1__VAL_2 =
	     (rg_count == 6'd4 && !mul_div || rg_count == 6'd33 && mul_div) ?
	       6'd0 :
	       x__h671 ;

  // register mul_div
  assign mul_div_D_IN = get_inputs_funct3[2] ;
  assign mul_div_EN = EN_get_inputs ;

  // register mult_reg_a
  assign mult_reg_a_D_IN = { 32'd0, op1__h787 } ;
  assign mult_reg_a_EN = EN_get_inputs && !get_inputs_funct3[2] ;

  // register mult_reg_b
  assign mult_reg_b_D_IN = { 32'd0, op2__h788 } ;
  assign mult_reg_b_EN = EN_get_inputs && !get_inputs_funct3[2] ;

  // register rg_complement
  always@(get_inputs_funct3 or
	  get_inputs_operand1_BIT_31_3_XOR_get_inputs_op_ETC___d78 or
	  get_inputs_operand1)
  begin
    case (get_inputs_funct3)
      3'd1, 3'd4:
	  rg_complement_D_IN =
	      get_inputs_operand1_BIT_31_3_XOR_get_inputs_op_ETC___d78;
      3'd2: rg_complement_D_IN = get_inputs_operand1[31];
      default: rg_complement_D_IN = get_inputs_funct3 == 3'd6;
    endcase
  end
  assign rg_complement_EN = MUX_rg_count_write_1__SEL_1 ;

  // register rg_count
  assign rg_count_D_IN =
	     MUX_rg_count_write_1__SEL_1 ?
	       6'd1 :
	       MUX_rg_count_write_1__VAL_2 ;
  assign rg_count_EN =
	     EN_get_inputs &&
	     (!get_inputs_funct3[2] || get_inputs_operand2 != 32'd0) ||
	     WILL_FIRE_RL_increment_counter ;

  // register rg_sign_op1
  assign rg_sign_op1_D_IN = get_inputs_operand1[31] ;
  assign rg_sign_op1_EN = EN_get_inputs ;

  // register rg_upperbits
  assign rg_upperbits_D_IN =
	     get_inputs_funct3[2] ?
	       get_inputs_funct3[1] :
	       get_inputs_funct3[1:0] != 2'd0 ;
  assign rg_upperbits_EN = MUX_rg_count_write_1__SEL_1 ;

  // submodule divider
  assign divider_get_inputs_op1 = op1__h787 ;
  assign divider_get_inputs_op2 = op2__h788 ;
  assign divider_get_inputs_qr = get_inputs_funct3[1] ;
  assign divider_EN_get_inputs =
	     EN_get_inputs && get_inputs_funct3[2] &&
	     get_inputs_operand2 != 32'd0 ;

  // remaining internal signals
  assign _theResult_____2_fst__h1641 =
	     get_inputs_funct3[1] ? get_inputs_operand1 : 32'hFFFFFFFF ;
  assign _theResult____h2001 =
	     (mul_div_AND_rg_upperbits_5_7_AND_rg_complement_ETC___d105 ||
	      mul_div && rg_complement && !rg_upperbits ||
	      !mul_div && rg_complement) ?
	       reslt___1__h2178 :
	       reslt__h2000 ;
  assign get_inputs_operand1_BIT_31_3_XOR_get_inputs_op_ETC___d78 =
	     get_inputs_operand1[31] ^ get_inputs_operand2[31] ;
  assign mul_div_AND_rg_upperbits_5_7_AND_rg_complement_ETC___d105 =
	     mul_div && rg_upperbits && rg_complement &&
	     divider_quo_rem[31] != rg_sign_op1 ;
  assign mult_reg_a_13_MUL_mult_reg_b_14___d115 = mult_reg_a * mult_reg_b ;
  assign op1__h787 = (t1__h785 ^ get_inputs_operand1) + { 31'd0, x__h1209 } ;
  assign op2__h788 = (t2__h786 ^ get_inputs_operand2) + { 31'd0, x__h1384 } ;
  assign product__h2002 =
	     (!mul_div && rg_upperbits) ?
	       _theResult____h2001[63:32] :
	       _theResult____h2001[31:0] ;
  assign reslt___1__h2178 = ~reslt__h2000 + 64'd1 ;
  assign reslt__h2000 =
	     mul_div ?
	       { 32'd0, divider_quo_rem } :
	       mult_reg_a_13_MUL_mult_reg_b_14___d115[63:0] ;
  assign t1__h785 = {32{x__h1209}} ;
  assign t2__h786 = {32{x__h1384}} ;
  assign x__h1209 =
	     !get_inputs_funct3[2] &&
	     get_inputs_funct3[0] ^ get_inputs_funct3[1] &&
	     get_inputs_operand1[31] ||
	     get_inputs_funct3[2] && !get_inputs_funct3[0] &&
	     get_inputs_operand1[31] ;
  assign x__h1384 =
	     !get_inputs_funct3[2] && get_inputs_funct3[1:0] == 2'd1 &&
	     get_inputs_operand2[31] ||
	     get_inputs_funct3[2] && !get_inputs_funct3[0] &&
	     get_inputs_operand2[31] ;
  assign x__h1935 =
	     get_inputs_funct3[2] ? y_avValue_fst__h1574 : 32'hFFFFFFFF ;
  assign x__h671 = rg_count + 6'd1 ;
  assign y_avValue_fst__h1574 =
	     (get_inputs_operand2 == 32'd0) ?
	       _theResult_____2_fst__h1641 :
	       32'hFFFFFFFF ;

  // handling of inlined registers

  always@(posedge CLK or `BSV_RESET_EDGE RST_N)
  if (RST_N == `BSV_RESET_VALUE)
    begin
      mul_div <= `BSV_ASSIGNMENT_DELAY 1'd0;
      mult_reg_a <= `BSV_ASSIGNMENT_DELAY 64'd0;
      mult_reg_b <= `BSV_ASSIGNMENT_DELAY 64'd0;
      rg_complement <= `BSV_ASSIGNMENT_DELAY 1'd0;
      rg_count <= `BSV_ASSIGNMENT_DELAY 6'd0;
      rg_sign_op1 <= `BSV_ASSIGNMENT_DELAY 1'd0;
      rg_upperbits <= `BSV_ASSIGNMENT_DELAY 1'd0;
    end
  else
    begin
      if (mul_div_EN) mul_div <= `BSV_ASSIGNMENT_DELAY mul_div_D_IN;
      if (mult_reg_a_EN) mult_reg_a <= `BSV_ASSIGNMENT_DELAY mult_reg_a_D_IN;
      if (mult_reg_b_EN) mult_reg_b <= `BSV_ASSIGNMENT_DELAY mult_reg_b_D_IN;
      if (rg_complement_EN)
	rg_complement <= `BSV_ASSIGNMENT_DELAY rg_complement_D_IN;
      if (rg_count_EN) rg_count <= `BSV_ASSIGNMENT_DELAY rg_count_D_IN;
      if (rg_sign_op1_EN)
	rg_sign_op1 <= `BSV_ASSIGNMENT_DELAY rg_sign_op1_D_IN;
      if (rg_upperbits_EN)
	rg_upperbits <= `BSV_ASSIGNMENT_DELAY rg_upperbits_D_IN;
    end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    mul_div = 1'h0;
    mult_reg_a = 64'hAAAAAAAAAAAAAAAA;
    mult_reg_b = 64'hAAAAAAAAAAAAAAAA;
    rg_complement = 1'h0;
    rg_count = 6'h2A;
    rg_sign_op1 = 1'h0;
    rg_upperbits = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_delayed_output)
	begin
	  TASK_testplusargs___d89 = $test$plusargs("fullverbose");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_delayed_output)
	begin
	  TASK_testplusargs___d90 = $test$plusargs("mmuldiv");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_delayed_output)
	begin
	  TASK_testplusargs___d91 = $test$plusargs("l0");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_delayed_output)
	begin
	  v__h2070 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_delayed_output &&
	  (TASK_testplusargs___d89 ||
	   TASK_testplusargs___d90 && TASK_testplusargs___d91))
	$write("[%10d", v__h2070, "] ");
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_delayed_output &&
	  (TASK_testplusargs___d89 ||
	   TASK_testplusargs___d90 && TASK_testplusargs___d91))
	$write("MULDIV: Responding with DelayedOut: %h", product__h2002);
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_delayed_output &&
	  (TASK_testplusargs___d89 ||
	   TASK_testplusargs___d90 && TASK_testplusargs___d91))
	$write("\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_get_inputs && !get_inputs_funct3[2])
	begin
	  TASK_testplusargs___d62 = $test$plusargs("fullverbose");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_get_inputs && !get_inputs_funct3[2])
	begin
	  TASK_testplusargs___d63 = $test$plusargs("mmuldiv");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_get_inputs && !get_inputs_funct3[2])
	begin
	  TASK_testplusargs___d64 = $test$plusargs("l0");
	  #0;
	end
    NOT_get_inputs_funct3_BIT_2_2_7_AND_TASK_testp_ETC___d67 =
	!get_inputs_funct3[2] &&
	(TASK_testplusargs___d62 ||
	 TASK_testplusargs___d63 && TASK_testplusargs___d64);
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_get_inputs && !get_inputs_funct3[2])
	begin
	  v__h955 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_get_inputs &&
	  NOT_get_inputs_funct3_BIT_2_2_7_AND_TASK_testp_ETC___d67)
	$write("[%10d", v__h955, "] ");
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_get_inputs &&
	  NOT_get_inputs_funct3_BIT_2_2_7_AND_TASK_testp_ETC___d67)
	$write("MULDIV : Inps to Mul. A:%h B:%h f3: %b",
	       op1__h787,
	       op2__h788,
	       get_inputs_funct3);
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_get_inputs &&
	  NOT_get_inputs_funct3_BIT_2_2_7_AND_TASK_testp_ETC___d67)
	$write("\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_increment_counter &&
	  (rg_count == 6'd4 && !mul_div || rg_count == 6'd33 && mul_div))
	begin
	  TASK_testplusargs___d13 = $test$plusargs("fullverbose");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_increment_counter &&
	  (rg_count == 6'd4 && !mul_div || rg_count == 6'd33 && mul_div))
	begin
	  TASK_testplusargs___d14 = $test$plusargs("mmuldiv");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_increment_counter &&
	  (rg_count == 6'd4 && !mul_div || rg_count == 6'd33 && mul_div))
	begin
	  TASK_testplusargs___d15 = $test$plusargs("l0");
	  #0;
	end
    rg_count_EQ_4_AND_NOT_mul_div_OR_rg_count_EQ_3_ETC___d18 =
	(rg_count == 6'd4 && !mul_div || rg_count == 6'd33 && mul_div) &&
	(TASK_testplusargs___d13 ||
	 TASK_testplusargs___d14 && TASK_testplusargs___d15);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_increment_counter &&
	  (rg_count == 6'd4 && !mul_div || rg_count == 6'd33 && mul_div))
	begin
	  v__h451 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_increment_counter &&
	  rg_count_EQ_4_AND_NOT_mul_div_OR_rg_count_EQ_3_ETC___d18)
	$write("[%10d", v__h451, "] ");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_increment_counter &&
	  rg_count_EQ_4_AND_NOT_mul_div_OR_rg_count_EQ_3_ETC___d18)
	$write("MULDIV : got output from Mul/Div. mul_div: %b", mul_div);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_increment_counter &&
	  rg_count_EQ_4_AND_NOT_mul_div_OR_rg_count_EQ_3_ETC___d18)
	$write("\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_increment_counter && (rg_count != 6'd4 || mul_div) &&
	  (rg_count != 6'd33 || !mul_div))
	begin
	  TASK_testplusargs___d25 = $test$plusargs("fullverbose");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_increment_counter && (rg_count != 6'd4 || mul_div) &&
	  (rg_count != 6'd33 || !mul_div))
	begin
	  TASK_testplusargs___d26 = $test$plusargs("mmuldiv");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_increment_counter && (rg_count != 6'd4 || mul_div) &&
	  (rg_count != 6'd33 || !mul_div))
	begin
	  TASK_testplusargs___d27 = $test$plusargs("l0");
	  #0;
	end
    NOT_rg_count_EQ_4_0_OR_mul_div_1_AND_NOT_rg_co_ETC___d30 =
	(rg_count != 6'd4 || mul_div) && (rg_count != 6'd33 || !mul_div) &&
	(TASK_testplusargs___d25 ||
	 TASK_testplusargs___d26 && TASK_testplusargs___d27);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_increment_counter && (rg_count != 6'd4 || mul_div) &&
	  (rg_count != 6'd33 || !mul_div))
	begin
	  v__h588 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_increment_counter &&
	  NOT_rg_count_EQ_4_0_OR_mul_div_1_AND_NOT_rg_co_ETC___d30)
	$write("[%10d", v__h588, "] ");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_increment_counter &&
	  NOT_rg_count_EQ_4_0_OR_mul_div_1_AND_NOT_rg_co_ETC___d30)
	$write("MULDIV : Waiting for mul/div to respond. Count: %d",
	       rg_count);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_increment_counter &&
	  NOT_rg_count_EQ_4_0_OR_mul_div_1_AND_NOT_rg_co_ETC___d30)
	$write("\n");
  end
  // synopsys translate_on
endmodule  // mkmuldiv

